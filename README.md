## Сценарий выполнения
* Для начала нужно найти rpc url для нужной сети, для дальнейшего подключения к блокчейну и записать в файл ```chains/test_chain.py```
Также требуется найти url для сайта scan. Заполняем оставшееся поле с название сети
* Дальше переходим к файлу ```test_exchange/contracts.py```, где есть функция для сбора пулов определённой сети в указанной бирже, которая на выход должна отдавать список из объектов класса Pool.
Данный класс принимает список из объектов класса Token, который представляет уникальный токен для данного пула. Класс Token принимает такие параметры, как symbol(название токена), decimal и address(адрес контракта токена)/
Возвращаясь к классу Pool, он также принимает такие параметры, как address(адрес контракта пула) и swap_fee, которое измеряется в доле(к примеру если пул имеет 0.3% комиссии, то требуется в объект передавать 0.3% / 100%).
Также ему нужно будет передавать объект класса Chain, который в дальнейшем инициализируем в файле ```test_exchange/exchange.py```.
Далее нужно будет прописать функцию для обновления всех пулов. Любыми способами, принимая любые аргументы, который также будем передавать с того же файла биржи. Он не должен ничего возвращать
* Переходим к настройке функции для подсчёта данных после свапа в определённом пуле (файл ```test_exchange/calculate.py```). 
  Функция ```calculate()``` принимает такие параметры, values (список из значений количества токенов на вход), path_pool (экземпляр класса PathPool(```classes/pool.py```))
  Этот класс принимает за основу объект класса Pool, из которого и будут в дальнейшем собираться данные, а также символы токенов в том порядке, в котором требуется произвести подсчёт свапа.
  На выход данной функции должен возвращаться список из значений количества токенов на выход после свапа, в соответствии с входными значениями.
* Теперь переходим к главному файлу биржи ```test_exchange/exchange.py```, где и происходит настройка и связка всех компонентов.
TestExchange - объект класса Exchange, который принимает параметры name, chains(список объектов класса BaseChain, одну из которых прописали в файле ```chains/test_chain.py```).
Далее нужно закинуть файлы abi(котракта пула и контракта токена) в папку ```test_exchange/data``` и считать их в соответствуюшщие аргументы contract_abi и token_abi.
Также требуется передать функцию для подсчётов токенов на выходе после свапа. Дальше, обращаюсь к данному объекту биржи мы настраиваем сеть, привязываю к ней функцию по инициализации пулов и дальнейшему обновлению их данных.
! Данные, которые требутеся обновлять, нужно будет узнать самому, как и формулу для подсчётов.
* Настройка биржи закончена, теперь требуется написать скрипт для проверки данных. В файле ```main.py``` прописана базовая инструкция, как она должна работать. Суть проста - есть определённая функция main(), которая в самом начале инициализирует пулы и записывает в объект класса Chain(Chain базируется на классе BaseChain и создается экзепляр при инициализаци объекта класса Exchange).
После того, как получили список пулов, их нужно будет обновлять, при помощи функции test_exchange.chains[0].update() (здесь мы берём нашу первую и единственную сеть и происходит обновление данных в пулах за счёт той самой функции, которую прописали в файле ```test_exchange/contracts.py```).
Данные должны обновляться в цикле постоянно. Также в этом цикле должны подсчитываться данные о количестве токенов на выходе после свапа. Для этого используем фукнцию ```test_exchange.calculate()```, которую прописывали ранее. 
В файле ```tests.py``` лежат тестовые данные, которые в дальнейшем для проверки могут быть изменены на другие токены и входные данные количества входных токенов.

### В каком случае тестовое задание является выполненным?
Тестовое задание считается выполненным, если выходные данные являются истинными (сверять с сайтом биржи). Так же имеет вес и скорость обновления данных в пулах и скорость инициализации этих же пулов. 

## Требования

* Вся логика биржи для данной сети должна лежать в файле ```uniswap/contracts.py```
* Нужные файлы (.json и др.) должны лежать в папке ```uniswap/data```
* Настройки биржи прописана в файле ```uniswap/exchange.py```
* Нужно будет написать список rpc uri для сети polygon в файле ```chains/polygon.py```
* Формула должна быть в файле ```uniswap/calculate.py```
* Нужно найти верную формулу подсчёта количества монет после выполнения обмена одного токена на другом через
  определённый пул. Использовать данную формулу для дальнейших подсчётов (не прибегая к использованию запросов для получения результата после свапа от uniswap)
* Вся логика должна быть написана на основе библиотек web3, httpx и др стандарные библиотеки (не используя стандартную
  библиотеку uniswap)
* Всё нужно будет реализовывать через классы в папке ```classes``` и используя базовую схему сети в папке ```chains``` 

## Самое главное

* Сбор обновления данных в пулах должен быть максимально быстрым (скорость работы программы - скорость от начала цикла работы до вывода результатов)
* Подсчёт количества токенов после свапа должен быть верным (сверить с биржей)
* Собрать все пулы, в которых TVL более 200$

## Результат выполнения

Основной файл - ```main.py```, где нужно будет выводить данные после свапа (более подробно описано в самом файле).

Список тестов будет в файле ```tests.py```, с помощью которого и будет проверять правильность данных (более подробно
также описано в файле ```main.py```)

### Удачи!